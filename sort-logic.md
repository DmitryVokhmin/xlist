Хорошо, давай по-другому. Разберём на конкретном примере — список из 8 чисел: `[5, 3, 8, 1, 9, 2, 7, 4]`.

---

## Точка входа: `PDQSort`

```go
func (p *XList[T]) PDQSort(compare func(a, b T) bool)
```

Захватывает мьютекс, создаёт `atomic.Int32` и `WaitGroup`, вызывает `pdqsortListP(home, end, n=8, limit=3, ...)`.

`limit = bits.Len(8) = 3` — это **бюджет плохих разбиений**. Если потратим все 3 — переключаемся на heapsort.

---

## Главный цикл: `pdqsortListP`

Это бесконечный цикл `for {}`. Каждая итерация — одно разбиение. Вместо двух рекурсивных вызовов — один рекурсивный (меньшая половина) и один итерационный (большая половина продолжает этот же цикл).

### Шаг 1: проверка размера

```
n=8 > maxInsertion(12)? Нет → insertionSort и выход
```

У нас n=8 ≤ 12, значит сразу уходим в **insertion sort** и всё.

Давай возьмём пример побольше чтобы показать всю логику — `[5, 3, 8, 1, 9, 2, 7, 4, 6, 11, 10, 15, 13, 20]`, n=14.

---

### Шаг 1: проверка размера

`n=14 > 12` → продолжаем.

### Шаг 2: проверка бюджета

`limit=4 > 0` → heapsort не нужен, продолжаем.

### Шаг 3: `choosePivotList(lo, n=14)`

Вычисляем три позиции: `i = n/4*1 = 3` (элемент `1`), `j = n/4*2 = 6` (элемент `7`), `k = n/4*3 = 10` (элемент `10`).

n=14 < 50 (shortestNinther) → медиана трёх без ninther.

Находим медиану из `{1, 7, 10}` → **pivot = 7** (offset=6). Считаем swap при сравнениях: `1<7<10` → 0 swap → возвращаем `(offset=6, hint=increasingHint)`.

### Шаг 4: проверка hint

`hint == increasingHint` → данные похожи на отсортированные. Вызываем `partialInsertionSortList`. Он проходит список и находит максимум 5 пар не по порядку. В нашем случае много инверсий → возвращает `false`. Продолжаем.

### Шаг 5: `partitionList(lo, hi, n=14, pivotOffset=6)`

Это **сердце алгоритма**. Разбиваем список вокруг pivot=7.

**Сначала** перемещаем pivot в `lo`: swap(lo, pivot) → список теперь `[7, 3, 8, 1, 9, 2, 5, 4, 6, 11, 10, 15, 13, 20]`, `pivotNode = lo`.

**Два указателя** с счётчиками позиций:
- `i` стартует на `lo.next` (offset `iOff=1`)
- `j` стартует на `hi` (offset `jOff=13`)

`i` движется **вправо** пока элемент < pivot(7): `3<7✓`, `8<7✗` — стоп. `iOff=2`, i указывает на `8`.

`j` движется **влево** пока элемент ≥ pivot(7): `20≥7✓`, `13≥7✓`, `15≥7✓`, `10≥7✓`, `11≥7✓`, `6<7✗` — стоп. `jOff=8`, j указывает на `6`.

`iOff(2) ≤ jOff(8)` → swap(i,j): меняем `8` и `6`. Список: `[7, 3, 6, 1, 9, 2, 5, 4, 8, 11, 10, 15, 13, 20]`.

Сдвигаем: `i → iOff=3` (элемент `1`), `j → jOff=7` (элемент `4`).

Продолжаем: i идёт вправо: `1<7✓`, `9<7✗` — стоп. `iOff=4`, i на `9`.
j идёт влево: `4<7✗` — стоп. `jOff=7`, j на `4`.

`iOff(4) ≤ jOff(7)` → swap(`9`, `4`). Список: `[7, 3, 6, 1, 4, 2, 5, 9, 8, 11, 10, 15, 13, 20]`.

Сдвигаем: `i → iOff=5`, `j → jOff=6`.

i идёт вправо: `2<7✓`, `5<7✓` — стоп на `iOff=7` (элемент `9`).
j идёт влево: `5<7✗` — стоп на `jOff=6` (элемент `5`).

`iOff(7) > jOff(6)` → **выход из цикла**.

Ставим pivot на место: swap(j, pivotNode) → swap(`5` и `7`). Список: `[5, 3, 6, 1, 4, 2, 7, 9, 8, 11, 10, 15, 13, 20]`.

Возвращаем: `mid = узел с 7`, `midOffset=6`, `alreadyPartitioned=false`.

**Результат:** всё что левее `7` — меньше него, всё правее — больше или равно. Список разбит на `[5,3,6,1,4,2]` | `7` | `[9,8,11,10,15,13,20]`.

### Шаг 6: выбор рекурсии

`leftLen=6`, `rightLen=7`. Правая часть больше → итерируемся по правой, рекурсируем по левой.

`rightLen(7) >= balanceThreshold(14/8=1)` → `wasBalanced=true`.

Левая `[5,3,6,1,4,2]` (n=6): `spawnOrRun` → n=6 < parallelThreshold(2048) → **синхронная рекурсия**.

Правая `[9,8,11,10,15,13,20]` (n=7): обновляем `lo = mid.next`, `n=7` → **следующая итерация цикла**.

---

## Рекурсия левой части: `[5,3,6,1,4,2]`, n=6

n=6 ≤ 12 → сразу **`insertionSortList`**.

Insertion sort работает так: берём каждый элемент начиная со второго и вставляем его на правильное место среди уже отсортированных левых элементов, двигаясь назад:

```
[5, 3, 6, 1, 4, 2]
 ↑  ↑
     3<5 → swap → [3, 5, 6, 1, 4, 2]
        6>5 → ok  → [3, 5, 6, 1, 4, 2]
           1<6 → swap → [3, 5, 1, 6, 4, 2]
           1<5 → swap → [3, 1, 5, 6, 4, 2]
           1<3 → swap → [1, 3, 5, 6, 4, 2]
              4<6 → swap → [1, 3, 5, 4, 6, 2]
              4<5 → swap → [1, 3, 4, 5, 6, 2]
              4>3 → ok
                 2<6→2<5→2<4→2<3→2>1 → [1, 2, 3, 4, 5, 6]
```

Результат: `[1, 2, 3, 4, 5, 6]`.

---

## Продолжение главного цикла: правая часть `[9,8,11,10,15,13,20]`, n=7

n=7 ≤ 12 → **`insertionSortList`** → `[8, 9, 10, 11, 13, 15, 20]`.

---

## Финальный результат

Собираем всё вместе:

```
[1, 2, 3, 4, 5, 6] + [7] + [8, 9, 10, 11, 13, 15, 20]
= [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 20]
```

Список отсортирован. Никаких перемещений узлов — только swap указателей `obj` внутри узлов.

---

## Когда подключаются остальные части?

| Ситуация | Что происходит |
|---|---|
| n ≤ 12 | insertion sort, выход |
| limit == 0 | heapsort (собирает указатели во временный slice, сортирует через max-heap) |
| hint == decreasing | `reverseRangeList` за O(n) переворачивает сегмент, затем обычный путь |
| много дубликатов | `partitionEqualList` группирует равные pivot элементы, они исключаются из дальнейшей рекурсии |
| несбалансированное разбиение | `breakPatternsList` случайно swap'ает 3 элемента около центра через xorshift PRNG |
| n ≥ 2048 и есть свободный воркер | `spawnOrRun` запускает рекурсию в горутине
